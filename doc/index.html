<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>SimpleVM</title>
        <meta http-equiv="content-type" content="text/html;charset=utf-8" />
        <meta name="generator" content="Geany 0.20" />
    </head>

    <body>
        <div style="width:10%; float:left">&nbsp;&nbsp;&nbsp;&nbsp;</div>
        <div style="width:60%; float:left">
            <h1>SimpleVM</h1><hr>
            <h2>Backstory</h2>
            <p>
                After my time mucking with the KritterKompiler, I decided to
                look further into program compilation and interpretation
                just because I had already had so much fun mucking with it.
                Initially, I was planning to write a simple interpreter for
                some language grammar but the Lisp syntax I wished to
                implement proved beyond the reach of my limited grasp of C
                and C++.
            </p>
            <p>
                DeWayne Perry mentioned to me that Pascal, Common Lisp and
                Java all share the language feature of building source to
                bytecode before program execution. This bytecode is targeted
                to a standard virtual machine and is thereby smaller  and
                faster than interpreting the source code yet cross-platform
                unlike compiled ASM. It took me a bit to appreciate just how
                easy this scheme could make my life simply because I was
                getting the idea of a Bytecode VM mixed up with that of a
                traditional BASIC-like interpreter but now that I'm over
                that hump, this project is the outcome.
            </p>
            <br>
            <h2>Overview</h2>
            <p>
                In my mucking with compiling code for the Critter platform,
                I rapidly ran into all of the limitations thereof in
                terms of IO capabilities (none), memory limitations (10
                integers) and instruction set (integer addition/subtraction
                only). Undeterred, I succeeded in implementing a looping
                construct using the provided global goto and conditional
                branching statements. I even made it so far as to write a
                logarithm implementation.
            </p>
            <p>
                The frustrating thing about compiling for the Critter
                platform was really just lack of capabilities. The Critter
                "bytecode" was designed for one thing - to script the
                actions of small insect-like entities in a game. It wasn't
                built for math, and that I made it as far as exponentiation
                and multiplications is either a testament to my stubbornness
                or brilliance. Not sure which myself.
            </p>
            <p>
                As a result of the Critter's platform limitations, I began
                to consider carefully exactly what the bare minimum
                operators were for a platform such as SimpleVM. After
                reading a bit about <a href='http://wikipedia.org/wiki/LLVM'
                >LLVM</a>'s bytecode, and then reading <a href='http://www.ece.cmu.edu/~koopman/stack_computers/sec3_2.html'>
                a really good design for a minimal stack machine</a>, I
                settled on the following design requirements.
            </p>
            <br>
            <h2>Goals</h2>
            <ul>
                <li><b>Booleans</b> - Basic C bool</li>
                <li><b>Logical branching</b> - C/Python if statement</li>
                <li><b>Logical And</b> - And by bits</li>
                <li><b>Logical Or</b> -  Or by bits</li>
                <li><b>Logical Not</b> - Not by bits</li>
                <li><b>Logical XOR</b> - XOR by bits.. gotta have it for major bitwhackin'</li>
                <li><b>Bitshift Right</b></li>
                <li><b>Bitshift Left</b></li>
                <li><b>Assignment</b> - non-typesafe memory to memory copy</li>
                <li><b>Integers</b> - Signed 32-bit integers</li>
                <li><b>Pointer</b> - Same as a C pointer</li>
                <li><b>Arrays</b> - Basic C-style continuous memory block of either integers or booleans</li>
                <li><b>Stacks</b> - Basic FIFO que of pointers</li>
                <li><b>STDIN/STDOUT IO</b></li>
            </ul>
            <br>
            <h2>Parse Structure</h2>
            <p>
                As this code is supposed to simulate the runtime environment
                of a very low-level processor, there are very few "builtin"
                features and the set of keywords is minimal. Keyword
                declaration is also not possible, subroutines and functions
                are accomplished purely with raw stacks and are expected
                to be emulated by a compiler, not written by hand.
            </p>
            <p>
                General Structure:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="BACKGROUND-COLOR: #CCCCCC">&optcode [&opt [&opt [&opt [&opt]]]]]</span><br>
                where &optcode is a string of length four chars or less
                terminated with a space and defined in the Bytecode Spec
                later in this document. Each &opt is a string of length
                n < 6 which is the name of a defined memory block.
            </p>
            <p>
                The VM itself is CASE-INSENSITVE when it comes to variable
                names and keywords, but the standard is for uppercase
                as that is what the VM coerces to during code execution.
            </p>
            <p>
                Note on optcodes - optcodes may NOT be overloaded.
                While traditionally some verbs such as "<<" and ">>" may
                be applied to multiple types of objects, for simplicity
                SimpleVM does not support type inference as such. At
                least in v1. At runtime, the VM will do type checking
                to ensure that the parameters' types match and errors
                will be thrown if they are inappropriate.
            </p>
            <h1>Bytecode Spec</h1><hr>
            <div style="width:45%;float:left;">
                <h2>Integers</h2>
                <table border=1>
                    <tr>
                        <th>OpCode</th>
                        <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><b>ADD</b></td>
                        <td>N1 N2 N3</td>
                        <td>N1 + N2 => N3</td>
                    </tr>
                    <tr>
                        <td><b>SUB</b></td>
                        <td>N1 N2 N3</td>
                        <td>N1 - N2 => N3</td>
                    </tr>
                    <tr>
                        <td><b>MUL</b></td>
                        <td>N1 N2 N3</td>
                        <td>N1 * N2 => N3</td>
                    </tr>
                    <tr>
                        <td><b>DIV</b></td>
                        <td>N1 N2 N3</td>
                        <td>N1 / N2 => N3</td>
                    </tr>
                    <tr>
                        <td><b>MOD</b></td>
                        <td>N1 N2 N3</td>
                        <td>N1 % N2 => N3</td>
                    </tr>
                </table>
            </div>
            <div style="width:45%; float:right">
                <h2>System</h2><hr>
                <p>
                    System opcodes are for the most part type-insentitive
                    or perform untyped operations.
                </p>
                <table border=1>
                    <tr>
                        <th>OpCode</th>
                        <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><b>DINT</b></td>
                        <td>N1</td>
                        <td>creates an int at N1</td>
                    </tr>
                    <tr>
                        <td><b>DBIT</b></td>
                        <td>N1</td>
                        <td>creates a bool N1</td>
                    </tr>
                    <tr>
                        <td><b>DPTR</b></td>
                        <td>N1 N2</td>
                        <td>creates a pointer at N1 to N2</td>
                    </tr>
                    <tr>
                        <td><b>SWAP</b></td>
                        <td>N1 N2</td>
                        <td>swaps the values at N1, N2. Type unsafe.</td>
                    </tr>
                    <tr>
                        <td><b>MCPY</b></td>
                        <td>N1 N2</td>
                        <td>raw memory copy of N1 to N2. Type unsafe.</td>
                    </tr>
                    <tr>
                        <td><b>DEL</b></td>
                        <td>N1</td>
                        <td>raw memory delete of whatever N1 points to.</td>
                    </tr>
                    <tr>
                        <td><b>GOTO</b></td>
                        <td>N1</td>
                        <td>Jumps to instruction N1</td>
                    </tr>
                    <tr>
                        <td><b>HALT</b></td>
                        <td></td>
                        <td>Term. execution</td>
                    </tr>
                </table>
            </div>
            <div style="width:45%; float:left">
                <h2>Logic & Binary</h2>
                <table border=1>
                    <tr>
                        <th>OpCode</th>
                        <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><b>OR</b></td>
                        <td>N1 N2 N3</td>
                        <td>N1 || N2 => N3</td>
                    </tr>
                    <tr>
                        <td><b>AND</b></td>
                        <td>N1 N2 N3</td>
                        <td>N1 && N2 => N3</td>
                    </tr>
                    <tr>
                        <td><b>NOT</b></td>
                        <td>N1 N3</td>
                        <td>!N1 => N3</td>
                    </tr>
                    <tr>
                        <td><b>XOR</b></td>
                        <td>N1 N2 N3</td>
                        <td>(N1 & !N2) || (!N1 & N2) => N3</td>
                    </tr>
                    <tr>
                        <td><b>RSFT</b></td>
                        <td>N1</td>
                        <td>shifts the value at N1 right one bit, truncating for space and padding with 0</td>
                    </tr>
                    <tr>
                        <td><b>LSFT</b></td>
                        <td>N1</td>
                        <td>shifts the value at N1 left one bit, truncating for space and padding with 0</td>
                    </tr>
                </table>
            </div>
            <div style="width:45%; float:right">
                <h2>Stacks</h2>
                <table border=1>
                    <tr>
                        <th>OpCode</th>
                        <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><b>PUSH</b></td>
                        <td>N1 N2 </td>
                        <td>push N1 onto stack N2</td>
                    </tr>
                    <tr>
                        <td><b>POP</b></td>
                        <td>N1 N2</td>
                        <td>pop from N1 into N2</td>
                    </tr>
                </table>
            </div>
            <div style="width:45%; float:left">
                <h2>Pointers</h2><hr>
                <p>
                    Within SimpleVM, pointers are untyped refferences
                    to some block of memory. They are intended to allow
                    for the implementation of features like arrays and
                    pass-by-refference, but for simplicity's sake they
                    will not feature typing.
                </p>
                <table border=1>
                    <tr>
                        <th>OpCode</th>
                        <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><b>INCR</b></td>
                        <td>N1</td>
                        <td>shifts the pointer one address right</td>
                    </tr>
                    <tr>
                        <td><b>DECR</b></td>
                        <td>N1</td>
                        <td>shifts the pointer one address left</td>
                    </tr>
                </table>
            </div>
        </div>
    </body>
</html>
