<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>SimpleVM</title>
        <meta http-equiv="content-type" content="text/html;charset=utf-8" />
        <meta name="generator" content="Geany 0.20" />
    </head>
    <div style="width:10%; height:100%; float:left">&nbsp;</div>
    <div style="width:60%; float:left">
        <h1>SimpleVM</h1><hr>
        <h2>Backstory</h2>
        <p>
            After my time mucking with the KritterKompiler, I decided to
            look further into program compilation and interpretation
            just because I had already had so much fun mucking with it.
            Initially, I was planning to write a simple interpreter for
            some language grammar but the Lisp syntax I wished to
            implement proved beyond the reach of my limited grasp of C
            and C++.
        </p>
        <p>
            DeWayne Perry mentioned to me that Pascal, Common Lisp and
            Java all share the language feature of building source to
            bytecode before program execution. This bytecode is targeted
            to a standard virtual machine and is thereby smaller  and
            faster than interpreting the source code yet cross-platform
            unlike compiled ASM. It took me a bit to appreciate just how
            easy this scheme could make my life simply because I was
            getting the idea of a Bytecode VM mixed up with that of a
            traditional BASIC-like interpreter but now that I'm over
            that hump, this project is the outcome.
        </p>
        <br>
        <h2>Overview</h2>
        <p>
            In my mucking with compiling code for the Critter platform,
            I rapidly ran into all of the limitations thereof in
            terms of IO capabilities (none), memory limitations (10
            integers) and instruction set (integer addition/subtraction
            only). Undeterred, I succeeded in implementing a looping
            construct using the provided global goto and conditional
            branching statements. I even made it so far as to write a
            logarithm implementation.
        </p>
        <p>
            The frustrating thing about compiling for the Critter
            platform was really just lack of capabilities. The Critter
            "bytecode" was designed for one thing - to script the
            actions of small insect-like entities in a game. It wasn't
            built for math, and that I made it as far as exponentiation
            and multiplications is either a testament to my stubbornness
            or brilliance. Not sure which myself.
        </p>
        <p>
            As a result of the Critter's platform limitations, I began
            to consider carefully exactly what the bare minimum
            operators were for a platform such as SimpleVM. After
            reading a bit about <a href='http://wikipedia.org/wiki/LLVM'
            >LLVM</a>'s bytecode, and then reading <a href='http://www.ece.cmu.edu/~koopman/stack_computers/sec3_2.html'>
            a really good design for a minimal stack machine</a>, I
            settled on the following design requirements.
        </p>
        <br>
        <h2>Goals</h2>
        <ul>
            <li><b>Booleans</b> - Basic C bool</li>
            <li><b>Logical branching</b> - C/Python if statement</li>
            <li><b>Logical And</b> - And by bits</li>
            <li><b>Logical Or</b> -  Or by bits</li>
            <li><b>Logical Not</b> - Not by bits</li>
            <li><b>Logical XOR</b> - XOR by bits.. gotta have it for major bitwhackin'</li>
            <li><b>Bitshift Right</b></li>
            <li><b>Bitshift Left</b></li>
            <li><b>Assignment</b> - non-typesafe memory to memory copy</li>
            <li><b>Integers</b> - Signed 32-bit integers</li>
            <li><b>Pointer</b> - Same as a C pointer</li>
            <li><b>Arrays</b> - Basic C-style continuous memory block of either integers or booleans</li>
            <li><b>Stacks</b> - Basic FIFO que of pointers</li>
            <li><b>STDIN/STDOUT IO</b></li>
        </ul>
        <br>
        <h2>Parse Structure</h2>
        <p>
            As this code is supposed to simulate the runtime environment
            of a very low-level processor, there are very few "builtin"
            features and the set of keywords is minimal. Keyword
            declaration is also not possible, subroutines and functions
            are accomplished purely with raw stacks and are expected
            to be emulated by a compiler, not written by hand.
        </p>
        <p>
            General Structure:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="BACKGROUND-COLOR: #CCCCCC">&optcode [&opt [&opt [&opt [&opt]]]]]</span><br>
            where &optcode is a string of length four chars or less
            terminated with a space and defined in the Bytecode Spec
            later in this document. Each &opt is a string of length
            n < 6 which is the name of a defined memory block.
        </p>
        <p>
            The VM itself is CASE-INSENSITVE when it comes to variable
            names and keywords, but the standard is for uppercase
            as that is what the VM coerces to during code execution.
        </p>
        <p>
            Note on optcodes - optcodes may NOT be overloaded.
            While traditionally some verbs such as "<<" and ">>" may
            be applied to multiple types of objects, for simplicity
            SimpleVM does not support type inference as such. At
            least in v1. At runtime, the VM will do type checking
            to ensure that the parameters' types match and errors
            will be thrown if they are inappropriate.
        </p>
        <h1>Bytecode Spec</h1><hr>
        <div style="width:45%;float:left;">
            <h2>Integers</h2>
            <table border=1>
                <tr>
                    <th>OpCode</th>
                    <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><b>ADD</b></td>
                    <td>N1 N2 N3</td>
                    <td>N1 + N2 => N3</td>
                </tr>
                <tr>
                    <td><b>SUB</b></td>
                    <td>N1 N2 N3</td>
                    <td>N1 - N2 => N3</td>
                </tr>
                <tr>
                    <td><b>MUL</b></td>
                    <td>N1 N2 N3</td>
                    <td>N1 * N2 => N3</td>
                </tr>
                <tr>
                    <td><b>DIV</b></td>
                    <td>N1 N2 N3</td>
                    <td>N1 / N2 => N3</td>
                </tr>
                <tr>
                    <td><b>MOD</b></td>
                    <td>N1 N2 N3</td>
                    <td>N1 % N2 => N3</td>
                </tr>
            </table>
        </div>
        <div style="width:45%; float:right">
            <h2>System</h2><hr>
            <p>
                System opcodes are for the most part type-insentitive
                or perform untyped operations.
            </p>
            <table border=1>
                <tr>
                    <th>OpCode</th>
                    <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><b>DINT</b></td>
                    <td>N1</td>
                    <td>creates an int at N1</td>
                </tr>
                <tr>
                    <td><b>DBIT</b></td>
                    <td>N1</td>
                    <td>creates a bool N1</td>
                </tr>
                <tr>
                    <td><b>DPTR</b></td>
                    <td>N1 N2</td>
                    <td>creates a pointer at N1 to N2</td>
                </tr>
                <tr>
                    <td><b>SWAP</b></td>
                    <td>N1 N2</td>
                    <td>swaps the values at N1, N2. Type unsafe.</td>
                </tr>
                <tr>
                    <td><b>MCPY</b></td>
                    <td>N1 N2</td>
                    <td>raw memory copy of N1 to N2. Type unsafe.</td>
                </tr>
                <tr>
                    <td><b>DEL</b></td>
                    <td>N1</td>
                    <td>raw memory delete of whatever N1 points to.</td>
                </tr>
                <tr>
                    <td><b>GOTO</b></td>
                    <td>N1</td>
                    <td>Jumps to instruction N1</td>
                </tr>
                <tr>
                    <td><b>HALT</b></td>
                    <td></td>
                    <td>Term. execution</td>
                </tr>
            </table>
        </div>
        <div style="width:45%; float:left">
            <h2>Logic & Binary</h2>
            <table border=1>
                <tr>
                    <th>OpCode</th>
                    <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><b>OR</b></td>
                    <td>N1 N2 N3</td>
                    <td>N1 || N2 => N3</td>
                </tr>
                <tr>
                    <td><b>AND</b></td>
                    <td>N1 N2 N3</td>
                    <td>N1 && N2 => N3</td>
                </tr>
                <tr>
                    <td><b>NOT</b></td>
                    <td>N1 N3</td>
                    <td>!N1 => N3</td>
                </tr>
                <tr>
                    <td><b>XOR</b></td>
                    <td>N1 N2 N3</td>
                    <td>(N1 & !N2) || (!N1 & N2) => N3</td>
                </tr>
                <tr>
                    <td><b>RSFT</b></td>
                    <td>N1</td>
                    <td>shifts the value at N1 right one bit, truncating for space and padding with 0</td>
                </tr>
                <tr>
                    <td><b>LSFT</b></td>
                    <td>N1</td>
                    <td>shifts the value at N1 left one bit, truncating for space and padding with 0</td>
                </tr>
            </table>
        </div>
        <div style="width:45%; float:right">
            <h2>Stacks</h2>
            <table border=1>
                <tr>
                    <th>OpCode</th>
                    <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><b>PUSH</b></td>
                    <td>N1 N2 </td>
                    <td>push N1 onto stack N2</td>
                </tr>
                <tr>
                    <td><b>POP</b></td>
                    <td>N1 N2</td>
                    <td>pop from N1 into N2</td>
                </tr>
            </table>
        </div>
        <div style="width:45%; float:right">
            <h2>Pointers</h2><hr>
            <p>
                Within SimpleVM, pointers are untyped refferences
                to some block of memory. They are intended to allow
                for the implementation of features like arrays and
                pass-by-refference, but for simplicity's sake they
                will not feature typing.
            </p>
            <table border=1>
                <tr>
                    <th>OpCode</th>
                    <th>Args&nbsp;&nbsp;&nbsp;&nbsp;</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><b>INCR</b></td>
                    <td>N1</td>
                    <td>shifts the pointer one address right</td>
                </tr>
                <tr>
                    <td><b>DECR</b></td>
                    <td>N1</td>
                    <td>shifts the pointer one address left</td>
                </tr>
            </table>
        </div>
        <div style="width:100%;float:right;">
            <h1>Memory Model</h1><hr>
            <h2>Overview</h2>
            <div style="width:95%;float:right;">
                <p>
                    Just a quick executive summary of the memory system
                    covering the basic void pointer container and the
                    integer indexing scheme which makes everything
                    really easy.
                </p>
            </div>
            <h2>Details</h2>
            <div style="width:95%;float:right;">
                <p>
                    Thge biggest sticking point for me in writing an implimentation
                    of this spec was a lack of a clear memory model for the final
                    virtual machine. This makes the mechanics of the pointers
                    and other memory-dependant features undefined and impossible
                    to implement.
                </p>
                <p>
                    Inefficient as it may be, this VM in the 1.0 version at
                    any rate will be based on a single linear array of type
                    VMData. The VMData struct (raw c) has a void pointer to some
                    block of memory defined at initialization time, an integer
                    flag which states internal type (int/float/bool/ptr.).
                    Scope does not exist as far as the actual VM is
                    concerned, all variables are globals. This makes memory
                    management for the VM a real breeze, but makes memory
                    leaks a very serious potential problem.
                </p>
                <h3>Allocate Memory</h3>
                <p>
                    The allocation operation is really easy.. figure out
                    how many blocks of memory will be required to store the
                    new data/litteral, increment the counter to the last
                    un-used memory cell and perform the requisite
                    assignment opperations on the memory to hand.
                </p>
                <p>
                    With some probability, it will me necessary to allocate
                    a new, bigger array and copy over the old elements. This
                    case must be accounted for.
                </p>
                <h3>Deallocate Memory</h3>
                <p>
                    Deallocation is slightly harder and certainly more
                    expensive as an operation, but is also comparatively
                    trivial. The deallocation operation is performed on an
                    index of the VM's memory. That index is "deleted" by
                    overwriting by shifting all the other memory to the
                    right of the target index left by the number of deleted
                    indices.
                </p>
                <p>
                    <b>WARNING -</b> the memory to which the deleted node's
                    void pointer refers <u>l>must</u> be dealloc'd,
                    otherwise the VM will leak memory with each delete op.
                </p>
                <p>
                    <b>SPECIAL CASE -</b> Somehow arrays have to be
                    accounted for. While I have yet to author a similarly
                    vague yet implementable spec for arrays, my mental
                    sketch therefore suggests that a dealloc operation on an
                    array will receive only a pointer to the "head" of the
                    array. The ENTIRE array must be iteratively deleted as
                    a series of nodes, so it would make sense to delay the
                    left shift as long as possible lest you perform o(n)
                    shifts on m data points.... not cheap. By delaying the
                    compacting operation we can make deletion O(N+M) not
                    O(N*M)
                </p>
            </div>
        </div>
        <div style="width:100%;float:right;">
            <h1>Arrays</h1>
            <p>
                Okay.. having bitten the bullet and written a spec for
                the raw memory system, here is how I'm going to hack
                arrays into existence. Basically I am going to use
                four extra blocks of memory but it should be worth the
                pain.
            </p>
            <table border="1">
                <tr align=center>
                    <td>-2</td>
                    <td>-1</td>
                    <td>0</td>
                    <td>1</td>
                    <td>...</td>
                    <td>n</td>
                    <td>n+1</td>
                    <td>n+2</td>
                </tr>
                <tr align=center>
                    <td>ARRAY_START (unique)</td>
                    <td>INT [array length]</td>
                    <td>[data]</td>
                    <td>[data]</td>
                    <td>[data]</td>
                    <td>[data]</td>
                    <td>ARRAY_END (unique)</td>
                    <td>*prt => [-1]</td>
                </tr>
            </table>
        </div>
        <div style="width:100%;float:right;">
            <h1>Pointers</h1>
            <p>
                I alluded to pointers in the spec for an array, but I
                (characteristically) failed to give a concrete
                definition. Well here it is.
            </p>
            <p>
                Because the raw memory is integer-indexed, the simplest
                thing to do is to make pointers simply specially flagged
                cases of the general integer object. This keeps the
                implementation of incrementing, decrementing and
                equality fairly easy. The hard part is figuring out the
            </p>
        </div>
    </div>
</html>
