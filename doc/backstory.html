<h2>Backstory</h2>
<p>
    After my time mucking with the KritterKompiler, I decided to
    look further into program compilation and interpretation
    just because I had already had so much fun mucking with it.
    Initially, I was planning to write a simple interpreter for
    some language grammar but the Lisp syntax I wished to
    implement proved beyond the reach of my limited grasp of C
    and C++.
</p>
<p>
    DeWayne Perry mentioned to me that Pascal, Common Lisp and
    Java all share the language feature of building source to
    bytecode before program execution. This bytecode is targeted
    to a standard virtual machine and is thereby smaller  and
    faster than interpreting the source code yet cross-platform
    unlike compiled ASM. It took me a bit to appreciate just how
    easy this scheme could make my life simply because I was
    getting the idea of a Bytecode VM mixed up with that of a
    traditional BASIC-like interpreter but now that I'm over
    that hump, this project is the outcome.
</p>
<br>
<h2>Overview</h2>
<p>
    In my mucking with compiling code for the Critter platform,
    I rapidly ran into all of the limitations thereof in
    terms of IO capabilities (none), memory limitations (10
    integers) and instruction set (integer addition/subtraction
    only). Undeterred, I succeeded in implementing a looping
    construct using the provided global goto and conditional
    branching statements. I even made it so far as to write a
    logarithm implementation.
</p>
<p>
    The frustrating thing about compiling for the Critter
    platform was really just lack of capabilities. The Critter
    "bytecode" was designed for one thing - to script the
    actions of small insect-like entities in a game. It wasn't
    built for math, and that I made it as far as exponentiation
    and multiplications is either a testament to my stubbornness
    or brilliance. Not sure which myself.
</p>
<p>
    As a result of the Critter's platform limitations, I began
    to consider carefully exactly what the bare minimum
    operators were for a platform such as SimpleVM. After
    reading a bit about <a href='http://wikipedia.org/wiki/LLVM'
    >LLVM</a>'s bytecode, and then reading <a href='http://www.ece.cmu.edu/~koopman/stack_computers/sec3_2.html'>
    a really good design for a minimal stack machine</a>, I
    settled on the following design requirements.
</p>
<br>
